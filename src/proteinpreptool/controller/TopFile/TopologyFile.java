package controller.TopFile;

/*******************************************************************************
 *
 *	Filename   :	TopologyFile.java
 *
 *	Author     :	njm
 *
 *
 *	Description:
 *
 *	Class representing a biomolecular topology file. Contains information
 *	relating to atoms, bonds, pairs, angles and diheadrals.
 *
 *	Version History: 20/05/19 (initial version)
 *
 *******************************************************************************/


import controller.ConsoleController;
import controller.Int2;
import controller.ProteinPrepToolException;
import controller.TopFile.*;

import java.util.ArrayList;
import java.util.Collections;

public class TopologyFile {

    private static String blockCommentAtTopOfTopFile = ";This a standalone topology file generated by "
            + ConsoleController.applicationName + System.lineSeparator() + ";for use with Haptimol FlexiDock.";



    private String name;
    private int nrxcl;
    private ArrayList<AtomTopology> atoms;
    private ArrayList<BondTopology> bonds;
    private ArrayList<PairTopology> pairs;
    private ArrayList<AngleTopology> angles;
    private ArrayList<DiheadralTopology> diheadrals;
    private ArrayList<String> includeStatements;
    private StringBuilder system;
    private StringBuilder molecules;
    private DefaultsTopology defaults;

    private String ffName;

    private ArrayList<String> cachedResidueList;

    //stores the start (x) and end (y) indices of each residue in the topology (after creation).
    private ArrayList<Int2> residueStartPoints;

    public TopologyFile() {
        this.atoms = new ArrayList<>();
        this.bonds = new ArrayList<>();
        this.pairs = new ArrayList<>();
        this.angles = new ArrayList<>();
        this.diheadrals = new ArrayList<>();

        this.includeStatements = new ArrayList();
        this.system = new StringBuilder();
        this.molecules = new StringBuilder();

        this.name = "";
        this.defaults = new DefaultsTopology();
        this.cachedResidueList = null;
        this.residueStartPoints = null;

    }

    public void addAtom(AtomTopology atom){
        atoms.add(atom);
    }

    public void addBond(BondTopology bond){
        bonds.add(bond);
    }

    public void addPair(PairTopology pair){
        pairs.add(pair);
    }

    public void addAngle(AngleTopology angle){
        angles.add(angle);
    }

    public void setNameAndRXCL(String name, int rxcl){
        this.name = name;
        this.nrxcl = rxcl;
    }

    public void addDiheadral(DiheadralTopology diheadral){
        diheadrals.add(diheadral);
    }

    public void setDefaults(DefaultsTopology defaults){
        this.defaults = defaults;
    }

    public void addIncludeStatement(String statement){
        this.includeStatements.add(statement);
    }

    public void addMolecules(String molecules){
        this.molecules.append(molecules).append(System.lineSeparator());
    }

    public void addSystem(String system){
        this.molecules.append(molecules).append(System.lineSeparator());
    }

    public AtomTopology getAtom(int index) throws ProteinPrepToolException {

        if(index >= this.atoms.size() || index < 0){
            throw new ProteinPrepToolException("Invalid atom index requested");
        }

        return this.atoms.get(index);
    }

    public int getNumberOfAtomsInTopology(){
        return atoms.size();
    }


    private void prepareCachedResidueInfo() {

        this.cachedResidueList = new ArrayList<>();
        this.residueStartPoints = new ArrayList<>();

        String currentResidue = "";
        int previousId = -1;

        for (int i = 0; i < atoms.size(); i++) {
            AtomTopology atm = atoms.get(i);
            if (!(currentResidue.equalsIgnoreCase(atm.getResidueID()))) {
                currentResidue = atm.getResidueID();
                cachedResidueList.add(currentResidue);
                if(previousId >=0 ){
                    this.residueStartPoints.get(previousId).y = i;
                }
                previousId++;
                this.residueStartPoints.add(new Int2(i, 0));
            }
        }


    }

    public ArrayList<String> getListOfResiudes() {

        if (cachedResidueList == null) {
            prepareCachedResidueInfo();
        }

        return this.cachedResidueList;
    }


    public ArrayList<AtomTopology> getResidue(int i) throws ProteinPrepToolException {

        if(this.residueStartPoints == null){
            prepareCachedResidueInfo();
        }

        if(i > residueStartPoints.size() || i < 0)
            throw new ProteinPrepToolException("Index out of bounds");

        Int2 resStartPoint = this.residueStartPoints.get(i);

        ArrayList<AtomTopology> tmp = new ArrayList<>();
        for (int id = resStartPoint.x; id < resStartPoint.y; id++){
            tmp.add(new AtomTopology(this.atoms.get(id)));
        }

        return tmp;

    }





    /**
     *
     * Generates a gromacs top file representation of the topology
     *
     * @return String representation of Gromacs top file
     */
    @Override
    public String toString(){

        String nl = System.lineSeparator();
        StringBuilder sb = new StringBuilder();

        sb.append(blockCommentAtTopOfTopFile);
        sb.append(nl);
        sb.append(nl);
        sb.append("#include \"" + ffName + "\"");
        sb.append(nl);


        sb.append("[ defaults ]").append(System.lineSeparator());
        sb.append(";\tnbfunc\tcomb-rule\tgen-pairs\tfudgeLJ\tfudgeQQ").append(System.lineSeparator());
        sb.append(defaults.toString());
        sb.append(System.lineSeparator());

        if(includeStatements.size() > 0) {
            sb.append("; The force field to be included").append(System.lineSeparator());
            sb.append(this.includeStatements.get(0));
            sb.append(System.lineSeparator());
        }
        sb.append("[ moleculetype ]").append(System.lineSeparator());
        sb.append(name).append("\t").append(this.nrxcl).append(System.lineSeparator());
        sb.append(System.lineSeparator());
        sb.append("[ atoms ]").append(nl);
        for (AtomTopology line : atoms){
            sb.append(line.toString()).append(nl);
        }
        sb.append(nl);
        sb.append("[ bonds ]").append(nl);
        for (BondTopology line : bonds){
            sb.append(line).append(nl);
        }


        sb.append(nl);
        sb.append("[ pairs ]").append(nl);
        for (PairTopology line : pairs){
            sb.append(line).append(nl);
        }

        sb.append(nl);
        sb.append("[ angles ]").append(nl);
        for (AngleTopology line : angles){
            sb.append(line).append(nl);
        }

        sb.append(nl);
        sb.append("[ dihedrals ]").append(nl);
        for(DiheadralTopology dh :  diheadrals){
            sb.append(dh).append(nl);
        }

        for (int i = 1; i < includeStatements.size(); i++){
            sb.append(includeStatements.get(i)).append(nl);
        }

        sb.append("[ system ]").append(nl);
        sb.append(this.system).append(nl);

        sb.append("[ molecules ]").append(nl);
        sb.append(this.molecules.toString());


        return sb.toString();

    }


    public int getNumberOfDiheadrals(){
        return this.diheadrals.size();
    }

    /**
     * Get diheadral
     *
     * @param id - index of dihedral to acquire.
     * @return Diheadral at ID, if valid. Else null.
     */
    public DiheadralTopology getDiheadral(int id){
        if(id < 0 || id > diheadrals.size())
            return null;

        return diheadrals.get(id);
    }

    public void setFFName(String name){
        this.ffName = name + "/forcefield.itp";
    }

    /**
     * Method used to update atom types. (When atomtypes are not in the forcefield, and an update is provided.)
     *
     *
     * @param oldAtomType :- atom type to be replaced.
     * @param newAtomType :- value to replace it with.
     */

    public void updateAtomRecord(String oldAtomType, String newAtomType){
        //Atom topology contains a hashmap of all atom types within the application. Makes this lookup and change
        //much faster, than iterating through the list.
        AtomType atm = AtomTopology.getAtomType(oldAtomType);

        //if atm is null, atom is not in hashtable.
        if(atm != null)
            atm.setType(newAtomType);


    }

    public int getNumberOfAngles() {
        return this.angles.size();
    }

    public int getNumberOfBonds(){
        return this.bonds.size();
    }

    public AngleTopology getAngleTopology(int id){
        if(id < 0 || id >= this.angles.size()){
            return null;
        }
        return this.angles.get(id);
    }

    public BondTopology getBondTopology(int id){
        if(id < 0 || id >= this.bonds.size()){
            return null;
        }
        return this.bonds.get(id);
    }

    public void orderPairs() {

        Collections.sort(pairs);

    }
}
